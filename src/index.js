const express = require('express');
const TelegramBot = require('node-telegram-bot-api');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
require('dotenv').config();

const { logger } = require('./utils/logger');
const SmartRouter = require('./services/smart-router');
const OilService = require('./services/oil-service');
const AIService = require('./services/ai-service');
const SubscriptionService = require('./services/subscription-service');

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});
app.use(limiter);

// Initialize services
const smartRouter = new SmartRouter();
const oilService = new OilService();
const aiService = new AIService();
const subscriptionService = new SubscriptionService();

// Initialize Telegram bot
const bot = new TelegramBot(process.env.TELEGRAM_BOT_TOKEN, { polling: true });

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    version: '1.0.0'
  });
});

// Webhook endpoint for Telegram
app.post('/webhook', express.json(), async (req, res) => {
  try {
    const update = req.body;
    await handleTelegramUpdate(update);
    res.sendStatus(200);
  } catch (error) {
    logger.error('Webhook error:', error);
    res.sendStatus(500);
  }
});

// Main bot logic
async function handleTelegramUpdate(update) {
  try {
    if (!update.message && !update.callback_query) {
      return;
    }

    const chatId = update.message?.chat?.id || update.callback_query?.message?.chat?.id;
    const user = update.message?.from || update.callback_query?.from;

    logger.info(`Received update from user ${user?.id} in chat ${chatId}`);

    // Handle callback queries
    if (update.callback_query) {
      await handleCallbackQuery(update.callback_query);
      return;
    }

    // Handle text messages
    if (update.message?.text) {
      await handleTextMessage(update.message);
    }

  } catch (error) {
    logger.error('Error handling Telegram update:', error);
  }
}

async function handleTextMessage(message) {
  const chatId = message.chat.id;
  const text = message.text;
  const user = message.from;

  try {
    // Analyze request using Smart Router
    const request = smartRouter.analyzeRequest({
      json: { message: { text, chat: { id: chatId }, from: user } }
    });

    logger.info(`Request type: ${request.requestType} from user ${user.id}`);

    // Route to appropriate handler
    switch (request.requestType) {
      case 'start_command':
        await handleStartCommand(chatId, user);
        break;
      
      case 'help_command':
        await handleHelpCommand(chatId);
        break;
      
      case 'oil_search':
        await handleOilSearch(chatId, request.oilName);
        break;
      
      case 'mood_request':
        await handleMoodRequest(chatId, request.mood, request.keywords);
        break;
      
      case 'subscription_inquiry':
        await handleSubscriptionInquiry(chatId, user, request);
        break;
      
      case 'music_request':
        await handleMusicRequest(chatId, request);
        break;
      
      case 'greeting':
        await handleGreeting(chatId, user);
        break;
      
      default:
        await handleUnknownRequest(chatId, text);
    }

  } catch (error) {
    logger.error('Error handling text message:', error);
    await sendErrorMessage(chatId);
  }
}

async function handleCallbackQuery(callbackQuery) {
  const chatId = callbackQuery.message.chat.id;
  const data = callbackQuery.data;
  const user = callbackQuery.from;

  try {
    logger.info(`Callback query: ${data} from user ${user.id}`);

    if (data === 'main_menu') {
      await sendMainMenu(chatId);
    } else if (data.startsWith('select_oil:')) {
      const oilName = data.replace('select_oil:', '');
      await handleOilSearch(chatId, oilName);
    } else if (data.startsWith('subscribe')) {
      await handleSubscriptionCallback(chatId, user, data);
    } else {
      await handleUnknownCallback(chatId, data);
    }

    // Answer callback query
    await bot.answerCallbackQuery(callbackQuery.id);

  } catch (error) {
    logger.error('Error handling callback query:', error);
    await sendErrorMessage(chatId);
  }
}

// Command handlers
async function handleStartCommand(chatId, user) {
  const welcomeMessage = `üåø **–ü—Ä–∏–≤–µ—Ç, ${user.first_name}! –Ø —Ç–≤–æ–π –ê—Ä–æ–º–∞-–ø–æ–º–æ—â–Ω–∏–∫!** üåø

‚ú® **–ß—Ç–æ —è —É–º–µ—é:**

üîç **–†–∞—Å—Å–∫–∞–∑–∞—Ç—å –ø—Ä–æ –ª—é–±–æ–µ –º–∞—Å–ª–æ:**
- –ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏: "–º—è—Ç–∞", "–ª–∞–≤–∞–Ω–¥–∞", "–ª–∏–º–æ–Ω"
- –ò–ª–∏: "—Ä–∞—Å—Å–∫–∞–∂–∏ –ø—Ä–æ —ç–≤–∫–∞–ª–∏–ø—Ç"

ü§ñ **–î–∞—Ç—å –Ω–∞—É—á–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:**
- "–Ω—É–∂–Ω–∞ —ç–Ω–µ—Ä–≥–∏—è" ‚Üí —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ —Å –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è–º–∏
- "—Ö–æ—á—É —Ä–∞—Å—Å–ª–∞–±–∏—Ç—å—Å—è" ‚Üí —Å–æ–≤–µ—Ç—ã —ç–∫—Å–ø–µ—Ä—Ç–æ–≤
- "–ø—Ä–æ—Å—Ç—É–¥–∞" ‚Üí –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ –ª–µ—á–µ–Ω–∏–∏

–ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ —á—Ç–æ —Ç–µ–±—è –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç! üòä`;

  await bot.sendMessage(chatId, welcomeMessage, {
    parse_mode: 'Markdown',
    reply_markup: {
      inline_keyboard: [
        [{ text: 'üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é', callback_data: 'main_menu' }]
      ]
    }
  });
}

async function handleHelpCommand(chatId) {
  const helpMessage = `üåø **–ü–æ–º–æ—â—å –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é –±–æ—Ç–∞**

üîç **–ü–æ–∏—Å–∫ –º–∞—Å–µ–ª:**
‚Ä¢ –ù–∞–∑–≤–∞–Ω–∏–µ –º–∞—Å–ª–∞: "–ª–∞–≤–∞–Ω–¥–∞", "–º—è—Ç–∞", "–ª–∏–º–æ–Ω"
‚Ä¢ –û–ø–∏—Å–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞: "–Ω—É–∂–Ω–∞ —ç–Ω–µ—Ä–≥–∏—è", "—Ö–æ—á—É —Ä–∞—Å—Å–ª–∞–±–∏—Ç—å—Å—è"
‚Ä¢ –°–∏–º–ø—Ç–æ–º—ã: "–≥–æ–ª–æ–≤–Ω–∞—è –±–æ–ª—å", "–ø—Ä–æ—Å—Ç—É–¥–∞", "—Å—Ç—Ä–µ—Å—Å"

üéµ **–ú—É–∑—ã–∫–∞–ª—å–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:**
‚Ä¢ "–º—É–∑—ã–∫–∞ –¥–ª—è —Ä–∞—Å—Å–ª–∞–±–ª–µ–Ω–∏—è"
‚Ä¢ "—á—Ç–æ –ø–æ—Å–ª—É—à–∞—Ç—å —Å –ª–∞–≤–∞–Ω–¥–æ–π"

üì± **–ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ —Å–æ–≤–µ—Ç—ã:**
‚Ä¢ "–ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è" - –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
‚Ä¢ "–Ω–∞—Å—Ç—Ä–æ–π–∫–∏" - –∏–∑–º–µ–Ω–∏—Ç—å –≤—Ä–µ–º—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π

üí° **–ü—Ä–∏–º–µ—Ä—ã –∑–∞–ø—Ä–æ—Å–æ–≤:**
‚Ä¢ "—Ä–∞—Å—Å–∫–∞–∂–∏ –ø—Ä–æ —ç–≤–∫–∞–ª–∏–ø—Ç"
‚Ä¢ "–Ω—É–∂–Ω–∞ —ç–Ω–µ—Ä–≥–∏—è"
‚Ä¢ "–º—É–∑—ã–∫–∞ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è"
‚Ä¢ "–ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ —Å–æ–≤–µ—Ç—ã"`;

  await bot.sendMessage(chatId, helpMessage, { parse_mode: 'Markdown' });
}

async function handleOilSearch(chatId, oilName) {
  try {
    const oil = await oilService.searchOil(oilName);
    
    if (oil) {
      const message = oilService.formatOilInfo(oil);
      await bot.sendMessage(chatId, message, {
        parse_mode: 'Markdown',
        reply_markup: {
          inline_keyboard: [
            [{ text: 'üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é', callback_data: 'main_menu' }]
          ]
        }
      });
    } else {
      const suggestions = oilService.getSuggestions(oilName);
      const notFoundMessage = oilService.formatNotFoundMessage(oilName, suggestions);
      await bot.sendMessage(chatId, notFoundMessage, { parse_mode: 'Markdown' });
    }
  } catch (error) {
    logger.error('Error in oil search:', error);
    await sendErrorMessage(chatId);
  }
}

async function handleMoodRequest(chatId, mood, keywords) {
  try {
    const oils = await oilService.getAllOils();
    const recommendation = await aiService.getMoodRecommendation(mood, oils, keywords);
    
    await bot.sendMessage(chatId, recommendation, {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [
          [{ text: 'üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é', callback_data: 'main_menu' }]
        ]
      }
    });
  } catch (error) {
    logger.error('Error in mood request:', error);
    await sendErrorMessage(chatId);
  }
}

async function handleSubscriptionInquiry(chatId, user, request) {
  try {
    const response = await subscriptionService.handleInquiry(chatId, user, request);
    await bot.sendMessage(chatId, response.message, {
      parse_mode: 'Markdown',
      reply_markup: response.keyboard
    });
  } catch (error) {
    logger.error('Error in subscription inquiry:', error);
    await sendErrorMessage(chatId);
  }
}

async function handleMusicRequest(chatId, request) {
  try {
    const musicRecommendation = await aiService.getMusicRecommendation(request);
    await bot.sendMessage(chatId, musicRecommendation, {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [
          [{ text: 'üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é', callback_data: 'main_menu' }]
        ]
      }
    });
  } catch (error) {
    logger.error('Error in music request:', error);
    await sendErrorMessage(chatId);
  }
}

async function handleGreeting(chatId, user) {
  const greetingMessage = `–ü—Ä–∏–≤–µ—Ç, ${user.first_name}! üòä

–Ø —Ç–≤–æ–π –ê—Ä–æ–º–∞-–ø–æ–º–æ—â–Ω–∏–∫! –ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ –º–Ω–µ, —á—Ç–æ —Ç–µ–±—è –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç:
‚Ä¢ –ù–∞–∑–≤–∞–Ω–∏–µ –º–∞—Å–ª–∞: "–ª–∞–≤–∞–Ω–¥–∞", "–º—è—Ç–∞"
‚Ä¢ –¢–≤–æ–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ: "–Ω—É–∂–Ω–∞ —ç–Ω–µ—Ä–≥–∏—è", "—Ö–æ—á—É —Ä–∞—Å—Å–ª–∞–±–∏—Ç—å—Å—è"
‚Ä¢ –ò–ª–∏ –ø—Ä–æ—Å—Ç–æ —Å–ø—Ä–æ—Å–∏: "—á—Ç–æ —Ç—ã —É–º–µ–µ—à—å?"`;

  await bot.sendMessage(chatId, greetingMessage);
}

async function handleUnknownRequest(chatId, text) {
  const unknownMessage = `ü§î –ù–µ —Å–æ–≤—Å–µ–º –ø–æ–Ω—è–ª –≤–∞—à –∑–∞–ø—Ä–æ—Å: "${text}"

üí° **–ü–æ–ø—Ä–æ–±—É–π—Ç–µ:**
‚Ä¢ –ù–∞–∑–≤–∞–Ω–∏–µ –º–∞—Å–ª–∞: "–ª–∞–≤–∞–Ω–¥–∞", "–º—è—Ç–∞", "–ª–∏–º–æ–Ω"
‚Ä¢ –û–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º—ã: "–Ω—É–∂–Ω–∞ —ç–Ω–µ—Ä–≥–∏—è", "—Å—Ç—Ä–µ—Å—Å"
‚Ä¢ –ö–æ–º–∞–Ω–¥—É: /help - –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø—Ä–∞–≤–∫–∏

–ò–ª–∏ –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏—Ç–µ "–ø–æ–º–æ—â—å" –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–¥—Ä–æ–±–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏! üòä`;

  await bot.sendMessage(chatId, unknownMessage);
}

async function handleSubscriptionCallback(chatId, user, data) {
  try {
    const response = await subscriptionService.handleCallback(chatId, user, data);
    await bot.sendMessage(chatId, response.message, {
      parse_mode: 'Markdown',
      reply_markup: response.keyboard
    });
  } catch (error) {
    logger.error('Error in subscription callback:', error);
    await sendErrorMessage(chatId);
  }
}

async function handleUnknownCallback(chatId, data) {
  const unknownCallbackMessage = `ü§î –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞: ${data}

–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ "–ø–æ–º–æ—â—å" –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø—Ä–∞–≤–∫–∏.`;

  await bot.sendMessage(chatId, unknownCallbackMessage);
}

async function sendMainMenu(chatId) {
  const mainMenuMessage = `üè† **–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é**

–í—ã–±–µ—Ä–∏—Ç–µ, —á—Ç–æ –≤–∞—Å –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç:`;

  const keyboard = {
    inline_keyboard: [
      [
        { text: 'üåø –ü–æ–∏—Å–∫ –º–∞—Å–ª–∞', callback_data: 'search_oil' },
        { text: 'üéµ –ú—É–∑—ã–∫–∞', callback_data: 'music' }
      ],
      [
        { text: 'üì± –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è', callback_data: 'subscribe' },
        { text: '‚ùì –ü–æ–º–æ—â—å', callback_data: 'help' }
      ]
    ]
  };

  await bot.sendMessage(chatId, mainMenuMessage, {
    parse_mode: 'Markdown',
    reply_markup: keyboard
  });
}

async function sendErrorMessage(chatId) {
  const errorMessage = `‚ùå **–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞**

–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ "–ø–æ–º–æ—â—å" –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø—Ä–∞–≤–∫–∏.`;

  await bot.sendMessage(chatId, errorMessage, { parse_mode: 'Markdown' });
}

// Error handling
bot.on('error', (error) => {
  logger.error('Telegram bot error:', error);
});

bot.on('polling_error', (error) => {
  logger.error('Telegram polling error:', error);
});

// Start server
app.listen(PORT, () => {
  logger.info(`üöÄ Aroma Helper Bot started on port ${PORT}`);
  logger.info(`üì± Bot username: @${bot.options.username}`);
});

// Graceful shutdown
process.on('SIGTERM', () => {
  logger.info('SIGTERM received, shutting down gracefully');
  bot.stopPolling();
  process.exit(0);
});

process.on('SIGINT', () => {
  logger.info('SIGINT received, shutting down gracefully');
  bot.stopPolling();
  process.exit(0);
}); 